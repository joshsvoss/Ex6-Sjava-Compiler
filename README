joshsvoss



=============================
=      File description     =
=============================

************************

PACKAGE: oop.ex6.main :  This package contains the main method and its class, Sjavac.java. It also
contains the parser and all of the exceptions that are thrown in the parser and not in the 
deeper methods that it calls.  It also contains the SymbolTableList class which wraps a Vector
of HashMaps for storing the variables at different scopes.  

DoubleDeclarationInScopeException.java - This Exception is to be thrown when two variable of the same 
name are declared in the same scope.

GlobalClosingBracketException.java - This exception is thrown when the parser encounters a closing bracket 
in the global scope.

GlobalIfWhileException.java - This exception is thrown when the parser encounters an if or while block in 
the global scope. 

GlobalMethodCallException.java - This exception is thrown when a method is called in the global scope.

GlobalReturnException.java - This exception is thrown when a return statement is encountered 
in the global scope.

IncorrectVariableSyntaxException - This exception is thrown when a variable is declared with 
incorrect syntax.  

MissingMethodReturnException.java -  This exception is thrown when a method is missing its return 
statement.  

NestedMethodDeclarationException.java - This exception is thrown when a method is declared inside another.  

Parser.java - This class handles reading in the Sjava file and parsing through it.

Sjavac.java - This class is the driver class of the Sjava code legality verifier. 

SJavacException.java - This is the parent exception for all exceptions of Sjava syntax nature.  All 
exceptions that are thrown because of a problem with the Sjava program specified in the cmd lin argument
extend this exception.

SymbolTableList.java - This is the class for the  SybolTableList, a data structure that holds our variables.

UndeclaredAssignmentException.java - This exception is thrown when the sjava program attempts to assign 
a value to a variable that hasn't been declared.  

UnmatchedSyntaxException.java - This exception is thrown when the line parsed doesn't 
match any of our regex formulas, and therefore must be incorrect.

WrongMethodNameException.java - This exception is thrown when a method is called with a name that 
doesn't exist.  

*****************************

PACKAGE: oop.ex6.scopes: This package contains the files that relate to checking the syntax
of code blocks and scopes: such as if statements, while loops and methods. It also contains the e
exceptions that they throw.  

IfWhile.java - This class performs static syntax validation checks on an if or while statement in 
Sjava document.  

IncorrectNumArgsException.java - This exception is thrown when a method is called with the incorrect number 
of args.  

InvalidParameterSyntaxException.java - This exception is thrown when the parameter declaration of a 
method is invalid.  

Method.java - This class implements the Method object, which houses all details of the method declared.

MethodNamespaceCollision.java - This exception is thrown when two methods have the same name.  

ParameterNotInitializedException - This exception is thrown when a method is called with passing arguments 
that haven't yet been initialized.


*****************************

PACKAGE: oop.ex6.types: This package contains the different Type objects and their superclass
Type.java and  the exceptions that they throw. 

AssignmentFromUninitializedVarException.java - This exception is thrown when one variable was assigned the 
value of another which wasn't initialized. 

AssignmentMismatchException.java - 

Boolean.java - This is the class for the Boolean Type variable.

Char.java - This is the class for the Char Type variable.

Double.java - This is the class for the Double Type variable.

FinalVariableException.java - This exception is thrown when a final variable is reassigned.

Int.java - This is the class for the Int Type variable.

InvalidTypeException.java - This exception is thrown when an illegal type is declared.

InvalidValueException.java - This exception is thrown when an illegal value is assigned to a variable.

StringType.java - This class implements the object StringType.  This class is used to create object that 
represent variable of the type String. The name "StringType" was used to avoid namespace collision with the 
Java class String.

Type.java - The parent class for all the type objects (Int, Char, etc).

TypeFactory.java - This class has the job of received a string that defines what type to create, and trying 
to create an instance of the corresponding type.

UninitializedFinalVariableException.java - This exception is thrown when a final variable is declared 
without initialization.

******************************


=============================
=          Design           =
=============================

We chose to divide the program into 3 different packages based on their different purposes.  The main 
package contains the driver class "Sjavac" and it's main method as well as the parser (and of course 
all of the exceptions that are thrown by these classes, this will be the case in each package), and the data
structure in which we stored the variables we created.
We decided to create objects for each type of variable, int, String, char etc, since in order 
to check the syntax of Sjava, we need the variables to persist so we can keep track of who they 
are (name) and what their value is, as well as if they've been initialized and are final etc.  
All the different variable objects extend the Type superclass, both to adhere to the DRY principle
by centralizing all common code in one place, and to be able to refer to all of the different types
by type Type, like we do when we create the symbol table HashMaps of type <String, Type>.
 
 We used the factory paradigm for creating instances of the different types, so it can 
 look a the string it's passed and attempt to create a object of the correct type.  This also allows
 us to catch the situation where the string specifies a type that we don't recognize, such as 
 "superBoolean b = true;", in which case we throw an exception.  
 
 The scopes package deals with parts of the code that are a scope of their own, namely: if statements, 
 while loops, and methods.  Out of these, only the methods need to actually be instantiated and 
 kept in a data structure so we can keep track of them.  Therefore, although we initially started with
 a common parent class Scope.java, as we progressed and realized that the ifWhile checks
 can be performed statically and there was no need to create an ifWhile object, we thinned out 
 the ifWhile.java class and got rid of all of it's unnecessary getters and setters, made it static
 and had the checks be performed inside checkLogic() instead of the constructor, and got rid 
 of the Scope parent class, since all of it's functionality was only used by the Method class.  
 
 To check the general syntax of each line of code from the source file, we used regexes. Creating one regex
 per legal type of line (i.e. variable declaration, method declaration, variable assignment, etc.). All of
 these regexes were placed in our parser class, allowing us to weed out any general syntax errors with the
 first read through. We also used a couple of other regexes, for example to ensure that legal values are
 assigned to the variables, as well as to split a list of paramters, variables, or conditions.
 
 Number of passes through file:
 We concluded 
 
 

=============================
=  Implementation details   =
=============================

See above.

=============================
=    Answers to questions   =
=============================
********************
ADDING OTHER VARIABLES:
Adding a new variable type to the spec of Sjava and therefore to our syntax verifier would fit
well with our design.  We already have a separate class for each type of variable, so we would just create
a new class in the types package, for example called "Float.java". It would have a constructor and implement
the other methods that Type demands: doesValueMatchType() and doesTargetTypeMatchSource().  The
first would make sure that the value assigned to the variable is of the right syntax, for example with a 
float "7" or "7.0" etc.
In addition, we'd have to change the regexes in the parser that deal with variable declarations
(as well as those in the parameter list of a method), by adding the option of having the type substring (eg.
"float") at the beginning of the variable declaration line.  

*********************
ADDING ARRAYS TO SJAVA:

Syntax issues for arrays:
1) Negative size declaration
2) Size variable has to be an int
3) The type of the array must be resolved to one or our Type subclasses, since objects don't exist in
SJava
4) The type must be the same on both sides of the assignment statement: String[] arr = int[x]; is illegal.
5) Statements like "arrayName[i]" would be legal only if arrayName pointed to an array type, and not
one of the other Type subclasses.  

We would add a class Array.java to the types package, and it would extend the Type class.  
This way we can keep track of a variable that references an array just like the other types 
in out SymbolTableList.  We need to keep track of declared arrays, because if a reference to an
array such as "arr[i]" or "arr.length" is referring to an array that hasn't been declared, that is 
illegal.  
The inherited abstract method "doesValueMatchType" would be implemented to throw an exception
if the assigned type of the array didn't match the declared type of the array, as well as 
ensuring that it is indeed assigned the value of an array. 




**********************
ADDING SWITCH STATEMENT:

In order to support the switch statement feature, we would implement a new class in the scopes package
called switch. Like the ifWhile class, it would not have a name, however, closer in functionality to the
method class, it would keep track of the argument passed through the switch. We can keep track of this by 
creating a field in the switch class that keeps track of the argument type. This is necessary to ensure 
that the cases following match the type of the argument. Other fields it would need are a declaration depth
variable to keep track of the opening and closing of the switch statement, as well as a boolean field
keeping track of whether or not we are under a switch case/default, say "inCase".
In our parser class, we would have to add regexes to account for all lines associated with the switch 
statement, "switch(..){", "case..:", default:", etc. We would also implement a stack data structure, to keep
track of open switch statementsAdditionally, we would add an else if block in out 
readCode() method to account for the opening of the switch statement. Upon entrance to this block,  



