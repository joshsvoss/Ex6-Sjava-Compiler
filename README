joshsvoss



=============================
=      File description     =
=============================

************************

PACKAGE: oop.ex6.main :  This package contains the main method and its class, Sjavac.java. It also
contains the parser and all of the exceptions that are thrown in the parser and not in the 
deeper methods that it calls.  It also contains the SymbolTableList class which wraps a Vector
of HashMaps for storing the variables at different scopes.  

DoubleDeclarationInScopeException.java - This Exception is to be thrown when two variable of the same 
name are declared in the same scope.

GlobalClosingBracketException.java - This exception is thrown when the parser encounters a closing bracket 
in the global scope.

GlobalIfWhileException.java - This exception is thrown when the parser encounters an if or while block in 
the global scope. 

GlobalMethodCallException.java - This exception is thrown when a method is called in the global scope.

GlobalReturnException.java - This exception is thrown when a return statement is encountered 
in the global scope.

IncorrectVariableSyntaxException - This exception is thrown when a variable is declared with 
incorrect syntax.  

MissingMethodReturnException.java -  This exception is thrown when a method is missing its return 
statement.  

NestedMethodDeclarationException.java - This exception is thrown when a method is declared inside another.  

Parser.java - This class handles reading in the Sjava file and parsing through it.

Sjavac.java - This class is the driver class of the Sjava code legality verifier. 

SJavacException.java - This is the parent exception for all exceptions of Sjava syntax nature.  All 
exceptions that are thrown because of a problem with the Sjava program specified in the cmd lin argument
extend this exception.

SymbolTableList.java - This is the class for the  SybolTableList, a data structure that holds our variables.

UndeclaredAssignmentException.java - This exception is thrown when the sjava program attempts to assign 
a value to a variable that hasn't been declared.  

UnmatchedSyntaxException.java - This exception is thrown when the line parsed doesn't 
match any of our regex formulas, and therefore must be incorrect.

WrongMethodNameException.java - This exception is thrown when a method is called with a name that 
doesn't exist.  

*****************************

PACKAGE: oop.ex6.scopes: This package contains the files that relate to checking the syntax
of code blocks and scopes: such as if statements, while loops and methods. It also contains the e
exceptions that they throw.  

IfWhile.java - This class performs static syntax validation checks on an if or while statement in 
Sjava document.  

IncorrectNumArgsException.java - This exception is thrown when a method is called with the incorrect number 
of args.  

InvalidParameterSyntaxException.java - This exception is thrown when the parameter declaration of a 
method is invalid.  

Method.java - This class implements the Method object, which houses all details of the method declared.

MethodNamespaceCollision.java - This exception is thrown when two methods have the same name.  

ParameterNotInitializedException - This exception is thrown when a method is called with passing arguments 
that haven't yet been initialized.


*****************************

PACKAGE: oop.ex6.types: This package contains the different Type objects and their superclass
Type.java and  the exceptions that they throw. 

AssignmentFromUninitializedVarException.java - This exception is thrown when one variable was assigned the 
value of another which wasn't initialized. 

AssignmentMismatchException.java - 

Boolean.java - This is the class for the Boolean Type variable.

Char.java - This is the class for the Char Type variable.

Double.java - This is the class for the Double Type variable.

FinalVariableException.java - This exception is thrown when a final variable is reassigned.

Int.java - This is the class for the Int Type variable.

InvalidTypeException.java - This exception is thrown when an illegal type is declared.

InvalidValueException.java - This exception is thrown when an illegal value is assigned to a variable.

StringType.java - This class implements the object StringType.  This class is used to create object that 
represent variable of the type String. The name "StringType" was used to avoid namespace collision with the 
Java class String.

Type.java - The parent class for all the type objects (Int, Char, etc).

TypeFactory.java - This class has the job of received a string that defines what type to create, and trying 
to create an instance of the corresponding type.

UninitializedFinalVariableException.java - This exception is thrown when a final variable is declared 
without initialization.

******************************


=============================
=          Design           =
=============================

We chose to divide the program into 3 different packages based on their different purposes.  The main 
package contains the driver class "Sjavac" and it's main method as well as the parser (and of course 
all of the exceptions that are thrown by these classes, this will be the case in each package), and the data
structure in which we stored the variables we created.
We decided to create objects for each type of variable, int, String, char etc, since in order 
to check the syntax of Sjava, we need the variables to persist so we can keep track of who they 
are (name) and what their value is, as well as if they've been initialized and are final etc.  
All the different variable objects extend the Type superclass, both to adhere to the DRY principle
by centralizing all common code in one place, and to be able to refer to all of the different types
by type Type, like we do when we create the symbol table HashMaps of type <String, Type>.
 
 We used the factory paradigm for creating instances of the different types, so it can 
 look a the string it's passed and attempt to create a object of the correct type.  This also allows
 us to catch the situation where the string specifies a type that we don't recognize, such as 
 "superBoolean b = true;", in which case we throw an exception.  
 
 The scopes package deals with parts of the code that are a scope of their own, namely: if statements, 
 while loops, and methods.  Out of these, only the methods need to actually be instantiated and 
 kept in a data structure so we can keep track of them.  Therefore, although we initially started with
 a common parent class Scope.java, as we progressed and realized that the ifWhile checks
 can be performed statically and there was no need to create an ifWhile object, we thinned out 
 the ifWhile.java class and got rid of all of it's unnecessary getters and setters, made it static
 and had the checks be performed inside checkLogic() instead of the constructor, and got rid 
 of the Scope parent class, since all of it's functionality was only used by the Method class.  
 
 To check the general syntax of each line of code from the source file, we used regexes. Creating one regex
 per legal type of line (i.e. variable declaration, method declaration, variable assignment, etc.). All of
 these regexes were placed in our parser class, allowing us to weed out any general syntax errors with the
 first read through. We also used a couple of other regexes, for example to ensure that legal values are
 assigned to the variables, as well as to split a list of paramters, variables, or conditions.
 
 Number of passes through file:
 We concluded that two passes over the text of the file was the best way to organize the parsing: 
 first to add all global variables to our symbol table list, and add all Method objects
 to our Method list (which is a hashmap).  We need to do this since anywhere inside one of the methods, 
 they can refer to either a 1) global variable or 2) a declared method.  So we need to know what 
 all of these are before we enter into the text INSIDE the methods.  Since some of these variable
 and method declarations may come physically AFTER a method's body, but LOGICALLY come BEFORE, 
 we ignore the method bodies on our first "Global" iteration.  While this isn't the fastest approach,
 we chose to sacrifice a negligible cost in time for an increase in the speed of coding and the level
 of readability.  
 Now the downside of this approach is two times reading the file from disk.  In our case, the code
 files that we deal with are small enough that this "extra" call to disk would be completely negligable.
 But if this syntax verifier were to be used with a LARGE suite of software, then it might be 
 worth it to get rid of the second read from disk by: Reading in all of the code file once, and
 saving it to memory in an array of Strings.  This way, yes you would have to access that string array
 twice just like the file, but it will be stored in RAM not the disk, which is a much 
 less expensive call.  
 
 

=============================
=  Implementation details   =
=============================

See above.

=============================
=    Answers to questions   =
=============================
********************
ADDING FLOAT VARIABLE:
Adding a float variable to the spec of Sjava and therefore to our syntax verifier would fit
well with our design.  We already have a separate class for each type of variable, so we would just create
a new class in the types package called "Float.java".  It would have a constructor and implement
the other methods that Type demands: doesValueMatchType() and doesTargetTypeMatchSource().  The
first would make sure that the value assigned to the float variable is of the right syntax, "7" or "7.0" 
etc.
In addition, we'd have to change the regexes in the parser that deal with variable declarations
(as well as those in the parameter list of a method), by adding the option of having the substring "float" 
at the beginning of the variable declaration line.  

*********************
ADDING ARRAYS TO SJAVA:

Syntax issues for arrays:
1) Size of the array in declaration must be > 0
2) Size variable has to be an int
3) The type of the array must be resolved to one or our Type subclasses, since objects don't exist in
SJava
4) The type must be the same on both sides of the assignment statement: String[] arr = int[x]; is illegal.
5) Statements like "arrayName[i]" would be legal only if arrayName pointed to an array type, and not
one of the other Type subclasses.  

We would add a class Array.java to the types package, and it would extend the Type class.  
This way we can keep track of a variable that references an array just like the other types 
in out SymbolTableList.  We need to keep track of declared arrays, because if a reference to an
array such as "arr[i]" or "arr.length" is referring to an array that hasn't been declared, that is 
illegal.  
The inherited abstract method "doesValueMatchType" would be implemented to throw an exception
if the assigned type of the array didn't match the declared type of the array, as well as 
ensuring that it is indeed assigned the value of an array. 
The inherited abstract method "doesTargetTypeMatchSource" would do the same checking but for 
assignments to declared array variables, not the "array litera" (if you will) of "new <type>[<size>];"




**********************
ADDING SWITCH STATEMENT:





